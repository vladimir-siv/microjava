package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

// #===# [S] GLOBAL #===#

parser code
{:
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token)
	{
		report_error("Syntax error", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatal error, parsing cannot continue", cur_token);
	}

	public void report_error(String message, Object info)
	{
		errorDetected = true;

		StringBuilder msg = new StringBuilder(message);

		if (info instanceof Symbol)
		{
			msg
				.append(" on line ")
				.append(((Symbol)info).left);
		}

		log.error(msg.toString());
	}

	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);

		if (info instanceof Symbol)
		{
			msg
				.append (" on line ")
				.append(((Symbol)info).left);
		}

		log.info(msg.toString());
	}

:}

init with
{:
	errorDetected = false;
:}

scan with
{:
	Symbol s = this.getScanner().next_token();

	//if (s != null && s.value != null)
	//{
	//	log.info(s.toString() + " " + s.value.toString());
	//}

	return s;
:}

// #===# [E] GLOBAL #===#


// #===# [S] TERMINALS #===#

// Keywords
terminal PROG;
terminal CONST, ENUM;
terminal PRINT, RETURN, VOID;
// Constants
terminal Integer INT;
terminal Character CHAR;
terminal Boolean BOOL;
// Identifiers
terminal String IDENT;
// Operators
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO;
terminal EQU, NEQ, GTR, GEQ, LSS, LEQ;
terminal AND, OR;
terminal EQUAL;
terminal INC, DEC;
terminal DOT, COMMA, SEMI;
terminal LPAREN, RPAREN;
terminal LBRACKET, RBRACKET;
terminal LBRACE, RBRACE;
// Control
terminal IF, ELSE;

// #===# [E] TERMINALS #===#


// #===# [S] NON TERMINALS #===#

nonterminal rs.etf.pp1.symboltable.concepts.Obj		Program, ProgDecl;

nonterminal											ConstDecl;

nonterminal											EnumDecl, EnumReg;
nonterminal											EnumConstDeclList;
nonterminal											EnumConstDecl, EnumOptValue;

nonterminal rs.etf.pp1.symboltable.concepts.Struct	VarDeclList;
nonterminal											VarDecl;

nonterminal rs.etf.pp1.symboltable.concepts.Struct	Type;

nonterminal											MethodDeclList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj		MethodDecl, MethodReg;
nonterminal											Params, ParamList, Param;
nonterminal											Args, ArgList;

nonterminal rs.etf.pp1.symboltable.concepts.Obj		Designator;

nonterminal											StatementList, Statement;
nonterminal											Unmatched, Matched;

nonterminal rs.etf.pp1.symboltable.concepts.Struct	Expr, Term, Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct	FuncCall;

nonterminal											Op;

// #===# [E] NON TERMINALS #===#


Program ::= (ProgramNode) PROG ProgDecl:decl VarDeclList LBRACE MethodDeclList RBRACE;
ProgDecl ::= (ProgDeclNode) IDENT:progName;

ConstDecl ::= (ConstNode) CONST Type:constType IDENT:constName;

EnumDecl ::= (EnumNode) EnumReg LBRACE EnumConstDeclList RBRACE;
EnumReg ::= (EnumDeclNode) ENUM IDENT:enumName;
EnumConstDeclList ::= (EnumConstListNode) EnumConstDeclList COMMA EnumConstDecl | (EnumConstNode) EnumConstDecl;
EnumConstDecl ::= (EnumConstDeclNode) IDENT:enumConstName EnumOptValue;
EnumOptValue ::= (EnumValueNode) EQUAL INT:value | (EnumEmptyValueNode) /* epsilon */;

VarDeclList ::= (VarListNode) VarDeclList VarDecl | (EmptyVarListNode) /* epsilon */;
VarDecl ::= (VarDeclNode) Type:varType IDENT:varName SEMI;

Type ::= (TypeNode) IDENT:typeName;

MethodDeclList ::= (MethodListNode) MethodDeclList MethodDecl | (EmptyMethodListNode) /* epsilon */;
MethodDecl ::= (MethodNode) MethodReg LPAREN Params RPAREN VarDeclList LBRACE StatementList RBRACE;
MethodReg ::= (MethodDeclNode) Type:retType IDENT:methodName;

Params ::= (ParamsNode) ParamList | (EmptyParamsNode) /* epsilon */;
ParamList ::= (ParamListNode) ParamList COMMA Param | (ParamNode) Param;
Param ::= (ParamDeclNode) Type IDENT;

Args ::= (ArgsNode) ArgList | (EmptyArgsNode) /* epsilon */;
ArgList ::= (ArgListNode) ArgList COMMA Expr | (ArgNode) Expr;

Designator ::= (DesignatorNode) IDENT:name;

StatementList ::= (StatementListNode) StatementList Statement | (EmptyStatementListNode) /* epsilon */;
Statement ::= (MatchedStmtNode) Matched | (UnmachedStmtNode) Unmatched | (ErrorStatement) error SEMI;

Unmatched ::= (UnmatchedIfNode) IF LPAREN Expr RPAREN Statement | (UnmatchedIfElseNode) IF LPAREN Expr RPAREN Matched ELSE Unmatched;
Matched ::=
	(MatchedIfNode) IF Expr Matched ELSE Matched
	|
	(AssignmentNode) Designator:dest EQUAL Expr:expr SEMI
	|
	(PrintNode) PRINT LPAREN Expr RPAREN SEMI
	|
	(ReturnExprNode) RETURN Expr:expr SEMI
	|
	(ReturnVoidNode) RETURN SEMI
	|
	(CallNode) FuncCall SEMI
	;

Expr ::=
	(OpExprNode) Expr:expr Op Term:term
	|
	(TermExprNode) Term:term
	;

Term ::= (FactorNode) Factor:factor;
Factor ::=
	(ConstantFactorNode) INT
	|
	(VariableFactorNode) Designator:designator
	|
	(CallFactorNode) FuncCall
	;

FuncCall ::= (FuncCallNode) Designator:callee LPAREN Args RPAREN;

Op ::= (AddopNode) PLUS ;
