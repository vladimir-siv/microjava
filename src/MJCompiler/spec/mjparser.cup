package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

// #===# [S] GLOBAL #===#

parser code
{:
	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token)
	{
		report_error("Syntax error", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatal error, parsing cannot continue", cur_token);
	}

	public void report_error(String message, Object info)
	{
		errorDetected = true;

		StringBuilder msg = new StringBuilder(message);

		if (info instanceof Symbol)
		{
			msg
				.append(" on line ")
				.append(((Symbol)info).left);
		}

		log.error(msg.toString());
	}

	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);

		if (info instanceof Symbol)
		{
			msg
				.append (" on line ")
				.append(((Symbol)info).left);
		}

		log.info(msg.toString());
	}

:}

init with
{:
	errorDetected = false;
:}

scan with
{:
	Symbol s = this.getScanner().next_token();

	//if (s != null && s.value != null)
	//{
	//	log.info(s.toString() + " " + s.value.toString());
	//}

	return s;
:}

// #===# [E] GLOBAL #===#


// #===# [S] TERMINALS #===#

// Keywords
terminal PROG;
terminal CONST, ENUM;
terminal PRINT, READ;
terminal RETURN, VOID;
// Constants
terminal Integer INT;
terminal Character CHAR;
terminal Boolean BOOL;
// Identifiers
terminal String IDENT;
// Operators
terminal PLUS, MINUS, MULTIPLY, DIVIDE, MODULO;
terminal EQU, NEQ, GTR, GEQ, LSS, LEQ;
terminal AND, OR;
terminal EQUAL;
terminal INC, DEC;
terminal DOT, COMMA, SEMI;
terminal LPAREN, RPAREN;
terminal LBRACKET, RBRACKET;
terminal LBRACE, RBRACE;
// Control
terminal IF, ELSE;

// #===# [E] TERMINALS #===#


// #===# [S] NON TERMINALS #===#

nonterminal rs.etf.pp1.symboltable.concepts.Obj		Program, ProgDecl;

nonterminal	rs.etf.pp1.symboltable.concepts.Struct	ConstValue;

nonterminal											SectionsDecl;
nonterminal											Section;

nonterminal											ConstSectList;
nonterminal											ConstSect;
nonterminal											ConstSectDecl;
nonterminal											ConstDeclList;
nonterminal											ConstDecl;

nonterminal											VarSectList;
nonterminal											VarSect;
nonterminal											VarSectDecl;
nonterminal											VarDeclList;
nonterminal											VarDecl;

nonterminal											EnumDecl, EnumReg;
nonterminal											EnumConstDeclList;
nonterminal											EnumConstDecl, EnumOptValue;

nonterminal rs.etf.pp1.symboltable.concepts.Struct	Type;

nonterminal											MethodDeclList;
nonterminal											MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj		MethodReg;
nonterminal	rs.etf.pp1.symboltable.concepts.Struct	MethodType;

nonterminal											Params, ParamList;
nonterminal	rs.etf.pp1.symboltable.concepts.Obj		Param;
nonterminal											Args, ArgList;
nonterminal											Arg;

nonterminal rs.etf.pp1.symboltable.concepts.Obj		Designator;

nonterminal											StatementList;
nonterminal											Statement, DesignatorStatement;
nonterminal											Unmatched, Matched;

nonterminal											PrintSpace;

nonterminal	rs.etf.pp1.symboltable.concepts.Struct	Condition, CondTerm, CondFact;

nonterminal rs.etf.pp1.symboltable.concepts.Struct	Expr, Term, Factor;

nonterminal											FuncCall;
nonterminal											Callee;

nonterminal											Relop, Addop, Mulop;
nonterminal											Unaryop;

// #===# [E] NON TERMINALS #===#


Program ::= (ProgramNode) ProgDecl:decl SectionsDecl LBRACE MethodDeclList RBRACE;
ProgDecl ::= (ProgDeclNode) PROG IDENT:progName;

ConstValue ::=
	(IntConstNode) INT:value
	|
	(CharConstNode) CHAR:value
	|
	(BoolConstNode) BOOL:value
	;

SectionsDecl ::= (SectionNode) SectionsDecl Section | (EmptySectionNode) /* epsilon */;
Section ::=
	(ConstSectionNode) ConstSect
	|
	(VarSectionNode) VarSect
	|
	(EnumSectionNode) EnumDecl
	;

ConstSectList ::= (ConstSectListNode) ConstSectList ConstSect | (EmptyConstSectListNode) /* epsilon */;
ConstSect ::= (ConstSectNode) ConstSectDecl ConstDeclList SEMI;
ConstSectDecl ::= (ConstSectDeclNode) CONST Type:constType;
ConstDeclList ::= (ConstListNode) ConstDeclList COMMA ConstDecl | (ConstNode) ConstDecl;
ConstDecl ::= (ConstDeclNode) IDENT:constName EQUAL ConstValue:value;

VarSectList ::= (VarSectListNode) VarSectList VarSect | (EmptyVarSectListNode) /* epsilon */;
VarSect ::= (VarSectNode) VarSectDecl VarDeclList SEMI;
VarSectDecl ::= (VarSectDeclNode) Type:varType;
VarDeclList ::= (VarListNode) VarDeclList COMMA VarDecl | (VarNode) VarDecl;
VarDecl ::= (VarDeclNode) IDENT:varName;

EnumDecl ::= (EnumNode) EnumReg LBRACE EnumConstDeclList RBRACE;
EnumReg ::= (EnumDeclNode) ENUM IDENT:enumName;
EnumConstDeclList ::= (EnumConstListNode) EnumConstDeclList COMMA EnumConstDecl | (EnumConstNode) EnumConstDecl;
EnumConstDecl ::= (EnumConstDeclNode) IDENT:enumConstName EnumOptValue;
EnumOptValue ::= (EnumValueNode) EQUAL INT:value | (EnumEmptyValueNode) /* epsilon */;

Type ::= (TypeNode) IDENT:typeName;

MethodDeclList ::= (MethodListNode) MethodDeclList MethodDecl | (EmptyMethodListNode) /* epsilon */;
MethodDecl ::= (MethodNode) MethodReg LPAREN Params RPAREN VarSectList LBRACE StatementList RBRACE;
MethodReg ::= (MethodDeclNode) MethodType IDENT:methodName;
MethodType ::= (TypedMethodNode) Type:retType | (VoidMethodNode) VOID;

Params ::= (ParamsNode) ParamList | (EmptyParamsNode) /* epsilon */;
ParamList ::= (ParamListNode) ParamList COMMA Param | (ParamNode) Param;
Param ::= (ParamDeclNode) Type:paramType IDENT:paramName;

Args ::= (ArgsNode) ArgList | (EmptyArgsNode) /* epsilon */;
ArgList ::= (ArgListNode) ArgList COMMA Arg | (ArgNode) Arg;
Arg ::= (ArgDeclNode) Expr;

Designator ::= (DesignatorChainNode) Designator DOT IDENT:chainedDesignatorName | (DesignatorNode) IDENT:name;

StatementList ::= (StatementListNode) StatementList Statement | (EmptyStatementListNode) /* epsilon */;
Statement ::= (MatchedStmtNode) Matched | (UnmachedStmtNode) Unmatched | (ErrorStatement) error SEMI;
DesignatorStatement ::=
	(AssignmentNode) Designator EQUAL Expr SEMI
	|
	(CallNode) FuncCall SEMI
	|
	(IncrementNode) Designator INC SEMI
	|
	(DecrementNode) Designator DEC SEMI
	;

Unmatched ::= (UnmatchedIfNode) IF LPAREN Condition RPAREN Statement | (UnmatchedIfElseNode) IF LPAREN Condition RPAREN Matched ELSE Unmatched;
Matched ::=
	(MatchedIfNode) IF LPAREN Condition RPAREN Matched ELSE Matched
	|
	(DesignatorStatementNode) DesignatorStatement
	|
	(BlockNode) LBRACE StatementList RBRACE
	|
	(PrintNode) PRINT LPAREN Expr PrintSpace RPAREN SEMI
	|
	(ReadNode) READ LPAREN Designator RPAREN SEMI
	|
	(ReturnExprNode) RETURN Expr SEMI
	|
	(ReturnVoidNode) RETURN SEMI
	;

PrintSpace ::= (PrintSpaceNode) COMMA INT:value | (DefaultPrintSpaceNode) /* epsilon */;

Condition ::= (ConditionOrNode) Condition OR CondTerm | (ConditionNode) CondTerm;
CondTerm ::= (CondTermAndNode) CondTerm AND CondFact | (CondTermNode) CondFact;
CondFact ::= (RelCondFactNode) Expr:lexpr Relop Expr:rexpr | (CondFactNode) Expr;

Expr ::= (AddExprNode) Expr Addop Term | (ExprNode) Unaryop Term;
Term ::= (MulTermNode) Term Mulop Factor | (TermNode) Factor;
Factor ::=
	(ConstantFactorNode) ConstValue
	|
	(VariableFactorNode) Designator
	|
	(CallFactorNode) FuncCall
	|
	(PriorityFactorNode) LPAREN Expr RPAREN
	;

FuncCall ::= (FuncCallNode) Callee LPAREN Args RPAREN;
Callee ::= (CalleeNode) Designator:calleeName;

Relop ::=
	(EquNode) EQU
	|
	(NeqNode) NEQ
	|
	(GtrNode) GTR
	|
	(GeqNode) GEQ
	|
	(LssNode) LSS
	|
	(LeqNode) LEQ
	;
Addop ::=
	(PlusNode) PLUS
	|
	(MinusNode) MINUS
	;
Mulop ::=
	(MultiplyNode) MULTIPLY
	|
	(DivideNode) DIVIDE
	|
	(ModuloNode) MODULO
	;

Unaryop ::= (UnaryMinusNode) MINUS | (UnaryPlusNode) /* epsilon */;
